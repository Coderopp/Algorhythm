{
  "topic": "intervals",
  "total_lessons": 6,
  "total_xp": 600,
  "lessons": [
    {
      "id": "overview",
      "title": "Overview",
      "description": "Our solution will sort the intervals, and then greedily try to add each interval to the set of non-overlapping intervals.",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Our solution will sort the intervals, and then greedily try to add each interval to the set of non-overlapping intervals.\n\nWe sort the intervals by their end times, and then iterate over each interval, keeping a count of all intervals that DO NOT overlap with the last interval in the non-overlapping set. We return the total number of intervals minus the count of NON-overlapping intervals.\n\nNon-Overlapping Intervals\n\nIf we sort by start time, we risk adding an interval that starts early but ends late, which will block us from adding other intervals until that interval ends.\n\nTo see why we sometimes want to sort by end times instead of start time, let's consider the question of finding the maximum number of non-overlapping intervals in a given list of intervals.",
          "keyPoints": [
            "Our solution will sort the intervals, and then greedily try to add each interval to the set of non-overlapping intervals.",
            "If we sort by start time, we risk adding an interval that starts early but ends late, which will block us from adding other intervals until that interval ends.",
            "To see why we sometimes want to sort by end times instead of start time, let's consider the question of finding the maximum number of non-overlapping intervals in a given list of intervals."
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "1",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "1",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "1,3",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 4,
              "state": {
                "array": "6,9",
                "pointers": {}
              },
              "highlight": [
                3
              ],
              "explanation": "Step 4",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 5,
              "state": {
                "array": "2,5",
                "pointers": {}
              },
              "highlight": [
                4
              ],
              "explanation": "Step 5",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "non-overlapping-intervals",
      "title": "Non-Overlapping Intervals",
      "description": "Handling non-overlapping intervals.",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Handling non-overlapping intervals.",
          "keyPoints": [
            "Handling non-overlapping intervals."
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "4,10",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "can-attend-meetings",
      "title": "Can Attend Meetings",
      "description": "Note that meetings ending and starting at the same time, such as (0,5) and (5,10), do not conflict.",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Note that meetings ending and starting at the same time, such as (0,5) and (5,10), do not conflict.\n\nOtherwise, the person can attend both meetings, and we continue to the next interval. If we reach the end of the list without finding any overlapping intervals, then the person can attend all meetings, and we return true.\n\nA person can attend all meetings if and only if none of the meetings overlap. By sorting the intervals by start time, we can easily check if any two consecutive intervals overlap.\n\nTwo overlapping meeting intervals\n\nWe iterate over each interval, beginning with the second interval in the sorted list. We compare the start time of the current interval with the end time of the previous interval. If the start time of the current interval is less than the end time of the previous interval, then the two intervals overlap and the person cannot attend both meetings, so we return false.",
          "keyPoints": [
            "Note that meetings ending and starting at the same time, such as (0,5) and (5,10), do not conflict.",
            "A person can attend all meetings if and only if none of the meetings overlap. By sorting the intervals by start time, we can easily check if any two consecutive intervals overlap.",
            "Two overlapping meeting intervals"
          ],
          "codeExample": null
        }
      }
    },
    {
      "id": "insert-interval",
      "title": "Insert Interval",
      "description": "Insert Interval",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "",
          "keyPoints": [],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "7,10",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "employee-free-time",
      "title": "Employee Free Time",
      "description": "This is because the problem asks for common free time when all employees are available, and we're only given their scheduled busy intervals within a certain working timeframe.",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "This is because the problem asks for common free time when all employees are available, and we're only given their scheduled busy intervals within a certain working timeframe.\n\nIn this phase, we return the employee free times by finding the gaps between the merged intervals. We can do this by iterating through the merged intervals, and creating a new interval from the end time of the current interval and the start time of the next interval.\n\nImportant Note on Boundaries\n\nTime after the latest busy interval (e.g., if the last meeting ends at 5:00 PM, we don't count 5:00-6:00 PM as \\\n\nTime before the earliest busy interval (e.g., if the first meeting starts at 9:00 AM, we don't count 8:00-9:00 AM as \\",
          "keyPoints": [
            "This is because the problem asks for common free time when all employees are available, and we're only given their scheduled busy intervals within a certain working timeframe.",
            "Time after the latest busy interval (e.g., if the last meeting ends at 5:00 PM, we don't count 5:00-6:00 PM as \\",
            "Time before the earliest busy interval (e.g., if the first meeting starts at 9:00 AM, we don't count 8:00-9:00 AM as \\",
            "We first want to flatten the list of intervals into a single list, and then sorting them by their start time to make the merge process easier."
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "0,2",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "2,11",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "10,15",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "merge-intervals",
      "title": "Merge Intervals",
      "description": "Merge Intervals",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "",
          "keyPoints": [],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "1",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "1,4",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "4,5",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    }
  ]
}