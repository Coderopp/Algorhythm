{
  "topic": "depth-first-search",
  "total_lessons": 21,
  "total_xp": 2100,
  "lessons": [
    {
      "id": "depth-first-search",
      "title": "Depth-First Search",
      "description": "We then look at the two most common ways graphs are represented during the coding interview, and how to traverse both representations with DFS. Then we work through problems that give us practice with the different types of graph problems that can be solved using DFS.",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "We then look at the two most common ways graphs are represented during the coding interview, and how to traverse both representations with DFS. Then we work through problems that give us practice with the different types of graph problems that can be solved using DFS.\n\nThis module teaches you how to solve coding interview questions using depth-first search. It is divided into 2 sections:\n\nDepth-First Search (DFS) is a traversal algorithm that visits all nodes in a tree or graph-like data structure. It can be applied to a wide variety of problems, making it the most important algorithm to know for the coding interview.\n\nWe start by learning how depth-first search traverses the nodes in a binary tree, which will teach us the fundamentals of the algorithm. We then learn how to solve binary tree interview questions using depth-first search and recursion, and apply what we learned by working through practice problems.",
          "keyPoints": [
            "This module teaches you how to solve coding interview questions using depth-first search. It is divided into 2 sections:"
          ],
          "codeExample": null
        }
      }
    },
    {
      "id": "surrounded-regions",
      "title": "Surrounded Regions",
      "description": "Surrounded Regions",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "",
          "keyPoints": [],
          "codeExample": null
        }
      }
    },
    {
      "id": "longest-univalue-path",
      "title": "Longest Univalue Path",
      "description": "Given the root of the binary tree, find the longest path where all nodes along the path have the same value. This path doesn't have to include the root node. Return the number of edges on that path, not the number of nodes.",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Given the root of the binary tree, find the longest path where all nodes along the path have the same value. This path doesn't have to include the root node. Return the number of edges on that path, not the number of nodes.\n\nLet's look at an example of how this works:\n\nIf the current node is a leaf node, then the longest univalue path rooted at those nodes is 0.\n\nDiameter of a Binary Tree\n\nThe idea is to have each recursive call return the length of the longest univalue path that is rooted at the current node to its parent. This way, the parent can use the return values from its children to calculate the longest univalue path that passes through the current node.",
          "keyPoints": [
            "Let's look at an example of how this works:",
            "If the current node is a leaf node, then the longest univalue path rooted at those nodes is 0.",
            "Calculating the Longest Univalue Path at a Node"
          ],
          "codeExample": null
        }
      }
    },
    {
      "id": "path-sum",
      "title": "Path Sum",
      "description": "Path Sum",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "",
          "keyPoints": [],
          "codeExample": null
        }
      }
    },
    {
      "id": "diameter-of-a-binary-tree",
      "title": "Diameter of a Binary Tree",
      "description": "Given the root of a binary tree, write a recursive function to find the diameter of the tree. The diameter of a binary tree is the length of the longest path (# of edges) between any two nodes in a tree. This path may or may not pass through the root.",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Given the root of a binary tree, write a recursive function to find the diameter of the tree. The diameter of a binary tree is the length of the longest path (# of edges) between any two nodes in a tree. This path may or may not pass through the root.\n\nThe diameter of a binary tree is equal to longest path between any two nodes in the tree. So we want to use depth-first search to visit each node, and at each node we'll calculate the length of the longest path that passes through that node. At the end, we'll return the maximum of those lengths.\n\nThe length of the longest path going through the root node in the tree above is 4.",
          "keyPoints": [
            "The length of the longest path going through the root node in the tree above is 4."
          ],
          "codeExample": null
        }
      }
    },
    {
      "id": "pacific-atlantic-water-flow",
      "title": "Pacific Atlantic Water Flow",
      "description": "Pacific Atlantic Water Flow",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "",
          "keyPoints": [],
          "codeExample": null
        }
      }
    },
    {
      "id": "calculate-tilt",
      "title": "Calculate Tilt",
      "description": "Calculate Tilt",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "",
          "keyPoints": [],
          "codeExample": null
        }
      }
    },
    {
      "id": "number-of-islands",
      "title": "Number of Islands",
      "description": "[\\n[1, 1, 0, 1],\\n[1, 1, 0, 1],\\n[1, 1, 0, 0]\\n]",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "[\\n[1, 1, 0, 1],\\n[1, 1, 0, 1],\\n[1, 1, 0, 0]\\n]\n\nWe'll walkthrough how the algorithm detects 2 islands in the example grid:",
          "keyPoints": [
            "[\\n[1, 1, 0, 1],\\n[1, 1, 0, 1],\\n[1, 1, 0, 0]\\n]",
            "We'll walkthrough how the algorithm detects 2 islands in the example grid:"
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "1, 1, 0, 1",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "1, 1, 0, 1",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "1, 1, 0, 0",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 4,
              "state": {
                "array": "2,22",
                "pointers": {}
              },
              "highlight": [
                3
              ],
              "explanation": "Step 4",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 5,
              "state": {
                "array": "21,31",
                "pointers": {}
              },
              "highlight": [
                4
              ],
              "explanation": "Step 5",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "return-values",
      "title": "Return Values",
      "description": "Given a binary tree, use Depth-First Search to find the sum of all nodes in the tree.",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Given a binary tree, use Depth-First Search to find the sum of all nodes in the tree.\n\nIn this unit, we will:\n\nProblem: Sum of Nodes\n\nCover a general approach we can use to determine return values when faced with a binary tree problem.\n\nIn the previous section, we learned how Depth-First Search traverses each node in a binary tree via a series of recursive calls. To solve binary tree interview problems, the next step is to have each recursive call to DFS return a value.",
          "keyPoints": [
            "Given a binary tree, use Depth-First Search to find the sum of all nodes in the tree.",
            "Cover a general approach we can use to determine return values when faced with a binary tree problem.",
            "To solve binary tree problems with DFS, we have to get used to solving problems recursively, which we do in the problem below:",
            "Walkthrough an example to demonstrate how recursion and return values are used to solve binary tree problems with Depth-First Search.",
            "Here's how to visualize the steps of the Depth-First Search solution to this problem:"
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "0,3",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "2,5",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "4,14",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "path-sum-ii",
      "title": "Path Sum II",
      "description": "The remaining target sum",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "The remaining target sum\n\nThese values must be passed down as parameters of the recursive call, so we need to introduce a helper function to help us recurse.\n\nWhenever we are at a leaf node, we can check if the value of the current node matches the target. If it does, we can add the current path to the global list of paths.\n\nThe values along the current path (starting from the root).\n\nThis is an example of a question which benefits from using a global variable that all recursive calls have access to store the list of all root-to-leaf paths that match the target sum.",
          "keyPoints": [
            "These values must be passed down as parameters of the recursive call, so we need to introduce a helper function to help us recurse.",
            "Whenever we are at a leaf node, we can check if the value of the current node matches the target. If it does, we can add the current path to the global list of paths.",
            "The values along the current path (starting from the root).",
            "This is an example of a question which benefits from using a global variable that all recursive calls have access to store the list of all root-to-leaf paths that match the target sum."
          ],
          "codeExample": null
        }
      }
    },
    {
      "id": "copy-graph",
      "title": "Copy Graph",
      "description": "Returning from a previously visited node.",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Returning from a previously visited node.\n\nAdd the value of the node as a key in the adjacency list, and a list of its neighbor's values as the value in the dictionary.\n\nWe can now take a closer look at the solution by visualizing each step as it traverses the graph below:",
          "keyPoints": [
            "Returning from a previously visited node.",
            "Add the value of the node as a key in the adjacency list, and a list of its neighbor's values as the value in the dictionary.",
            "We can now take a closer look at the solution by visualizing each step as it traverses the graph below:"
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "0,3",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "2,4",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "3,9",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 4,
              "state": {
                "array": "8,11",
                "pointers": {}
              },
              "highlight": [
                3
              ],
              "explanation": "Step 4",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "graphs",
      "title": "Graphs",
      "description": "When working with DFS on a graph, the most important thing to remember is to keep track of the visited nodes as you traverse, since graphs (unlike trees) can contain cycles.",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "When working with DFS on a graph, the most important thing to remember is to keep track of the visited nodes as you traverse, since graphs (unlike trees) can contain cycles.\n\nDepth-First Search is also used to solve interview questions involving graphs.\n\nyou should be very comfortable with implementing basic DFS on both types of graphs\n\nGraphs consist of nodes (also frequently referred to as vertices), and edges that connect the nodes.",
          "keyPoints": [
            "When working with DFS on a graph, the most important thing to remember is to keep track of the visited nodes as you traverse, since graphs (unlike trees) can contain cycles.",
            "Depth-First Search is also used to solve interview questions involving graphs.",
            "you should be very comfortable with implementing basic DFS on both types of graphs",
            "Graphs consist of nodes (also frequently referred to as vertices), and edges that connect the nodes."
          ],
          "codeExample": null
        }
      }
    },
    {
      "id": "maximum-depth-of-a-binary-tree",
      "title": "Maximum Depth of a Binary Tree",
      "description": "Given the root of a binary tree, write a recursive function to find its maximum depth, where maximum depth is defined as the number of nodes along the longest path from the root node down to a leaf node.",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Given the root of a binary tree, write a recursive function to find its maximum depth, where maximum depth is defined as the number of nodes along the longest path from the root node down to a leaf node.",
          "keyPoints": [],
          "codeExample": null
        }
      }
    },
    {
      "id": "matrices",
      "title": "Matrices",
      "description": "Another common way to represent a graph is as a matrix (2D-grid). Each cell in the grid represents a node. The neighbors of each node are the cells that are adjacent to it (in the up, down, left, and right directions).",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Another common way to represent a graph is as a matrix (2D-grid). Each cell in the grid represents a node. The neighbors of each node are the cells that are adjacent to it (in the up, down, left, and right directions).\n\ngrid[1][1] is a node. Its neighbors are grid[0][1], grid[2][1], grid[1][0], and grid[1][2]\n\nDFS on a matrix is similar to DFS on an adjacency list. We still have to keep track of visited nodes, and we recursively call DFS on each neighbor of the current node.\n\nThe main difference is that each cell can have at most 4 neighbors (up, down, left, right), and that we need to check if the neighbor is within the bounds of the grid before visiting it.",
          "keyPoints": [
            "grid[1][1] is a node. Its neighbors are grid[0][1], grid[2][1], grid[1][0], and grid[1][2]",
            "DFS on a matrix is similar to DFS on an adjacency list. We still have to keep track of visited nodes, and we recursively call DFS on each neighbor of the current node.",
            "The main difference is that each cell can have at most 4 neighbors (up, down, left, right), and that we need to check if the neighbor is within the bounds of the grid before visiting it."
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "1, 0, 1",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "1, 0, 0",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "0, 0, 1",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 4,
              "state": {
                "array": "1",
                "pointers": {}
              },
              "highlight": [
                3
              ],
              "explanation": "Step 4",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 5,
              "state": {
                "array": "1",
                "pointers": {}
              },
              "highlight": [
                4
              ],
              "explanation": "Step 5",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "validate-binary-search-tree",
      "title": "Validate Binary Search Tree",
      "description": "Validate Binary Search Tree",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "",
          "keyPoints": [],
          "codeExample": null
        }
      }
    },
    {
      "id": "fundamentals",
      "title": "Fundamentals",
      "description": "Let's now look at the implementation of DFS on a binary tree. We'll pay special attention to the role that recursion and the call stack play in the algorithm.",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Let's now look at the implementation of DFS on a binary tree. We'll pay special attention to the role that recursion and the call stack play in the algorithm.\n\nA binary search tree. All nodes in the left subtree are less than 4, while all nodes in the right subtree are greater than 4.\n\nDepth-First Search is an algorithm used to traverse each node in a binary tree. It starts at the root node and tries to go \\\n\nDepth-First Search (DFS)\n\nPushing to the Call Stack",
          "keyPoints": [
            "Let's now look at the implementation of DFS on a binary tree. We'll pay special attention to the role that recursion and the call stack play in the algorithm.",
            "A binary search tree. All nodes in the left subtree are less than 4, while all nodes in the right subtree are greater than 4.",
            "Depth-First Search is an algorithm used to traverse each node in a binary tree. It starts at the root node and tries to go \\",
            "Pushing a new call frame onto the call stack."
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "0,2",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "1,4",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "3,7",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 4,
              "state": {
                "array": "6,22",
                "pointers": {}
              },
              "highlight": [
                3
              ],
              "explanation": "Step 4",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "types-of-dfs",
      "title": "Types of DFS",
      "description": "When that completes, we have fully explored a single island, and we move onto the next island, which is the next unvisited cell in the matrix that contains a 1.",
      "difficulty": "medium",
      "xp": 100,
      "type": "quiz",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "When that completes, we have fully explored a single island, and we move onto the next island, which is the next unvisited cell in the matrix that contains a 1.\n\nIf the cell contains a 1, then we use DFS to traverse all land cells neighboring that cell (marking cells as visited as we go).\n\nHere's what that looks like animated:\n\nWe traverse over each unvisited cell in the matrix.\n\nThese types of problems involve starting a DFS traversal from the boundary of a matrix. An example of this is finding all \\",
          "keyPoints": [
            "When that completes, we have fully explored a single island, and we move onto the next island, which is the next unvisited cell in the matrix that contains a 1.",
            "If the cell contains a 1, then we use DFS to traverse all land cells neighboring that cell (marking cells as visited as we go).",
            "Here's what that looks like animated:",
            "We traverse over each unvisited cell in the matrix.",
            "These types of problems involve starting a DFS traversal from the boundary of a matrix. An example of this is finding all \\"
          ],
          "codeExample": null
        }
      }
    },
    {
      "id": "flood-fill",
      "title": "Flood Fill",
      "description": "Backtracking to the previous pixel",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Backtracking to the previous pixel\n\nThe algorithm starts at the given starting pixel and uses depth-first search to explore all pixels connected 4-directionally to it. At each pixel, it first checks to see if the pixel is the same color as the starting pixel. If it is, it changes the color of the pixel and continues to explore the connected pixels.\n\nSetting the color of connected pixels.\n\nAfter changing that pixel's color, the algorithm will continue to explore the connected pixels of that pixel. Whenever it encounters a pixel that is not the same color as the starting pixel, it will return immediately and backtrack to the previous pixel on the call stack, which will then continue to explore its remaining connected pixels.",
          "keyPoints": [
            "Backtracking to the previous pixel",
            "Setting the color of connected pixels."
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "3,6",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "6,13",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "graph-valid-tree",
      "title": "Graph Valid Tree",
      "description": "[[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "[[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]\n\nBuilding the adjacency list.\n\nThe graph must contain no cycles.\n\nThere should be a single connected component - if we start from any node, we should be able to reach all other nodes.\n\nIn order for a graph to be a valid tree, it must satisfy the following conditions:",
          "keyPoints": [
            "[[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]",
            "The graph must contain no cycles.",
            "There should be a single connected component - if we start from any node, we should be able to reach all other nodes.",
            "In order for a graph to be a valid tree, it must satisfy the following conditions:"
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "0, 1",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "1, 2",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "2, 3",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 4,
              "state": {
                "array": "1, 3",
                "pointers": {}
              },
              "highlight": [
                3
              ],
              "explanation": "Step 4",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 5,
              "state": {
                "array": "1, 4",
                "pointers": {}
              },
              "highlight": [
                4
              ],
              "explanation": "Step 5",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "helper-functions-and-global-variables",
      "title": "Helper Functions and Global Variables",
      "description": "The animation below visualizes each step of the solution. Pay attention to how the max value seen so far on the current path from the root is passed down from parent to child nodes via the parameter in the helper function.",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "The animation below visualizes each step of the solution. Pay attention to how the max value seen so far on the current path from the root is passed down from parent to child nodes via the parameter in the helper function.\n\nIn some cases, questions require us to pass information \\\n\nNode 4: The root node is a \\\n\nExtra Step: Determining if a Node is \\\n\nIn the Return Values section, we covered how return values allow us to solve binary tree problems from the \\",
          "keyPoints": [
            "In some cases, questions require us to pass information \\",
            "Extra Step: Determining if a Node is \\",
            "In the Return Values section, we covered how return values allow us to solve binary tree problems from the \\",
            "Let's look at an example of a question that requires a helper function.",
            "Output: 3. The good nodes are highlighted in green (4, 7, 9)"
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "4, 2",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "4, 2, 1",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "4, 2, 3",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 4,
              "state": {
                "array": "4, 7",
                "pointers": {}
              },
              "highlight": [
                3
              ],
              "explanation": "Step 4",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 5,
              "state": {
                "array": "4, 7, 6",
                "pointers": {}
              },
              "highlight": [
                4
              ],
              "explanation": "Step 5",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    },
    {
      "id": "adjacency-list",
      "title": "Adjacency List",
      "description": "Some questions require you to build an adjacency list from a list of edges, which is shown below:",
      "difficulty": "medium",
      "xp": 100,
      "type": "theory",
      "mobileOptimized": true,
      "content": {
        "theory": {
          "explanation": "Some questions require you to build an adjacency list from a list of edges, which is shown below:\n\nThe next step is to practice using DFS to solve graph questions involving adjacency lists.\n\nIn Python, we can create an adjacency list using a dictionary where the keys are the nodes and the values are the list of nodes each node is connected to.\n\nAn adjacency list is a common way to represent a graph. In an adjacency list, we are given a list of nodes, where each node is mapped to a list of its neighbors.\n\nAn adjacency list representation of an undirected graph.",
          "keyPoints": [
            "Some questions require you to build an adjacency list from a list of edges, which is shown below:",
            "The next step is to practice using DFS to solve graph questions involving adjacency lists.",
            "In Python, we can create an adjacency list using a dictionary where the keys are the nodes and the values are the list of nodes each node is connected to.",
            "An adjacency list is a common way to represent a graph. In an adjacency list, we are given a list of nodes, where each node is mapped to a list of its neighbors.",
            "An adjacency list representation of an undirected graph."
          ],
          "codeExample": null
        },
        "visualization": {
          "type": "code-execution",
          "code": "# Code extracted from RSC",
          "language": "python",
          "steps": [
            {
              "line": 1,
              "state": {
                "array": "2",
                "pointers": {}
              },
              "highlight": [
                0
              ],
              "explanation": "Step 1",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 2,
              "state": {
                "array": "1, 3, 4",
                "pointers": {}
              },
              "highlight": [
                1
              ],
              "explanation": "Step 2",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 3,
              "state": {
                "array": "2, 4",
                "pointers": {}
              },
              "highlight": [
                2
              ],
              "explanation": "Step 3",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 4,
              "state": {
                "array": "2, 3, 5",
                "pointers": {}
              },
              "highlight": [
                3
              ],
              "explanation": "Step 4",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            },
            {
              "line": 5,
              "state": {
                "array": "4",
                "pointers": {}
              },
              "highlight": [
                4
              ],
              "explanation": "Step 5",
              "mobileView": {
                "compactArrayView": true,
                "largeTouch": true,
                "swipeEnabled": true
              }
            }
          ],
          "mobileOptimized": true,
          "controls": {
            "playPause": true,
            "stepForward": true,
            "stepBackward": true,
            "reset": true,
            "speed": [
              0.5,
              1,
              1.5,
              2
            ]
          }
        }
      }
    }
  ]
}